# ELEC2645 - PWM LED Control Lab

This lab introduces **Pulse Width Modulation (PWM)** for controlling LED brightness on the STM32L476 Nucleo board. You'll learn how to generate PWM signals at various frequencies and duty cycles to create different lighting effects and smooth brightness control.

The most important file is [Core/Src/main.c](Core/Src/main.c) which contains the main application demonstrating PWM LED control with multiple examples.

## The Project

The program demonstrates LED brightness control using PWM with three interactive examples:

1. **Example 1: Different PWM Frequencies** - LED flashes at different rates (5 Hz, 25 Hz, 1 kHz, 5 kHz)
2. **Example 2: Brightness Control** - Smooth fade up and fade down (0% to 100% duty cycle)
3. **Example 3: Breathing Effect** - LED smoothly "breathes" in and out like a heartbeat

Each example runs once at startup, demonstrating different PWM capabilities for controlling light output, motor speed, servo position, and other applications.

The PWM signal is generated on **PB6** using **Timer 4 (TIM4) Channel 1** with configurable frequency (10 Hz to 50 kHz) and duty cycle (0-100%).

## The Assignment

Your task is to enhance this PWM lab with custom effects and interactive controls:

**Your Tasks:**
1. **Create a custom LED effect** - Design your own animation pattern (e.g., strobe, saw-tooth ramp, pulse train)
2. **Combine with LCD display** - Show current PWM settings (frequency, duty cycle) on the screen
3. **Bonus - Add joystick or button control** - Make effects interactive (change frequency/brightness with joystick or button). Read the value of the Blue Button like in the Magic8Ball example (HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) or use the Joystick Read functions. 

## Setup Instructions

### Prerequisites

1. **Completed previous labs**
   - Blinky and LCD Test to ensure the hardware is working first!

2. **Configure the Project**
   - Open the `Unit_3_3_PWM` folder in VS Code (or the unit/project folder containing this lab)
   - When prompted "*Would you like to configure discovered CMake project as STM32Cube project*", click **Yes**
   - Allow the STM32 extension to complete initialization
   - Select **Debug** configuration when prompted

3. **Verify Hardware Connection**
   - Connect the Nucleo board via USB
   - Check that the board appears under "STM32CUBE Devices and Boards" in the Run and Debug sidebar
   - Test with the **Blink** function to verify communication

4. **Build and Run**
   - Click **Build** in the bottom status bar to verify compilation
   - Open Run and Debug panel (`Ctrl+Shift+D`)
   - Select **"STM32Cube: STLink GDB Server"** and click Run
   - Continue past breakpoints with **F5** or the play button
   - Watch the LED on the breadboard, LCD display showing "PWM LED Library Test", and monitor `printf()` output in the Serial Monitor

### Troubleshooting

- **Board not detected**: Ensure ST Link drivers are installed and USB cable is connected
- **Build errors**: Clean the build folder and rebuild: use **Build** > **Clean all**
- **LED not lighting up**: 
  - Verify LED is connected to **PB6** (PWM_Pin - see Hardware Configuration below)
  - Check that the power and ground connections are correct
  - Test with oscilloscope to confirm PWM signal on PB6
- **Serial communication issues**: Verify the serial port in the Serial Monitor (typically `COM3` or higher on Windows)

## Hardware Configuration

### LED Connection for PWM Control

| Component | Signal | Nucleo Pin | Purpose |
|-----------|--------|-----------|---------|
| LED (+) | PWM Output | PB6 | PWM signal for brightness control |
| LED (-) | Ground (via resistor) | GND | Current return path |
| Resistor | Current limiting | In series with LED | Protects LED (typically 220Ω - 1kΩ) |

**Connection Diagram:**
```
Nucleo PB6 ----[220Ω]------[LED +]
                           [LED -]
                             |
Nucleo GND ------------------+
```

⚠️ **Important Notes:**
- **PB6 provides PWM output** - this is your controlled signal
- **Use a current-limiting resistor** (220Ω to 1kΩ typical) to protect the LED and pin
- **Use common cathode connection** - connect LED negative to ground through resistor
- LED brightness is controlled by the **duty cycle** (percentage of time the signal is HIGH)

### Timer Configuration (TIM4)

The PWM signal is generated by Timer 4 (TIM4) Channel 1:
- **Timer**: TIM4
- **Channel**: CH1 (PB6)
- **Prescaler**: 79 (produces 1 MHz timer clock from 80 MHz input)
- **Frequency Range**: 10 Hz to 50 kHz (configurable)
- **Duty Cycle Range**: 0% to 100%

### Serial Communication

- **UART Interface**: USB connection via ST Link debugger
- **Baud Rate**: 115200 (configured in [Core/Src/usart.c](Core/Src/usart.c))
- **Purpose**: Debug output via `printf()` showing current PWM frequency and duty cycle

## Software Architecture

### Key Source Files

| File | Purpose |
|------|---------|
| [Core/Src/main.c](Core/Src/main.c) | **Main application logic** - PWM examples and demonstration |
| [Core/Inc/main.h](Core/Inc/main.h) | Main header with configuration macros and function prototypes |
| [Core/Src/tim.c](Core/Src/tim.c) | **Timer 4 initialization** - PWM hardware setup |
| [Core/Src/gpio.c](Core/Src/gpio.c) | GPIO peripheral initialization for all pins |
| [Core/Src/usart.c](Core/Src/usart.c) | UART/Serial communication setup |
| [Core/Src/stm32l4xx_it.c](Core/Src/stm32l4xx_it.c) | Interrupt handlers (button press, systick, UART) |

### PWM Library

The project includes a custom PWM control library:
- **Location**: [PWM/](PWM/)
- **Main Functions**:
  - `PWM_Init(cfg)` - Initialize PWM configuration
  - `PWM_Set(cfg, freq_hz, duty_percent)` - Set frequency and duty cycle
  - `PWM_SetFreq(cfg, freq_hz)` - Change frequency while keeping duty cycle
  - `PWM_SetDuty(cfg, duty_percent)` - Change brightness (0-100%)
  - `PWM_SetTicks(cfg, on_ticks, off_ticks)` - Direct tick-level control
  - `PWM_Off(cfg)` - Stop PWM output
  - `PWM_IsRunning(cfg)` - Check if PWM is currently active
- See [PWM/PWM.h](PWM/PWM.h) for full API documentation

### LCD Driver

The project includes an external ST7789V2 LCD driver for display feedback:
- **Location**: [ST7789V2_Driver_STM32L4/](ST7789V2_Driver_STM32L4/)
- **Usage**: Displays "PWM LED Library Test" on startup
- **Key Functions**:
  - `LCD_init(cfg)` - Initialize the LCD display
  - `LCD_printString(text, x, y, palette_index, scale)` - Display text at specified coordinates
  - `LCD_Fill_Buffer(color)` - Fill the screen buffer with a color
  - `LCD_Refresh(cfg)` - Update the display with buffer contents
  - See the driver README for complete API documentation

### Build System

- **Build Tool**: CMake with Ninja generator
- **Configuration**: [CMakeLists.txt](CMakeLists.txt)
- **Build Output**: Compiled binary in `build/Debug/Unit_3_3_PWM.elf`

## Serial Communication & Debugging

The `printf()` function has been redirected to the UART serial port by implementing a custom `_write()` function in [Core/Src/main.c](Core/Src/main.c). This allows you to use `printf()` as normal for debugging, and the output automatically transmits over the USB serial connection to your computer.

**Serial Configuration:**
- **Baud Rate**: 115200 bps
- **Data Format**: 8 bits, 1 stop bit, no parity
- **Connection**: USB via ST Link on the Nucleo board (virtual COM port)
- **Serial Monitor**: Use VS Code Serial Monitor extension to view real-time output

**Example printf output:**
```
=== ELEC2645 PWM Library Example ===
This example demonstrates the pwm.h library
The LED uses Timer 4 PWM on Channel 1

Example 1: Testing different PWM frequencies at 50% duty...
  10 Hz - LED flashing visible
  25 Hz - LED flashing faster
  1000 Hz - Smooth brightness (1kHz)
  5000 Hz - Very smooth (5kHz)
  ...
```

## STM32 HAL API Reference - PWM Control

### Timer PWM Functions

- `HAL_TIM_PWM_Start(htim, channel)` - Enable PWM output on specified timer/channel
  - Example: `HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1)` starts PB6 PWM output
  
- `HAL_TIM_PWM_Stop(htim, channel)` - Disable PWM output
  - Example: `HAL_TIM_PWM_Stop(&htim4, TIM_CHANNEL_1)` stops PB6 PWM

- `__HAL_TIM_SET_COMPARE(htim, channel, value)` - Set PWM duty cycle (CCR register)
  - Example: `__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, 500)` sets 50% duty (if ARR=999)
  - Duty cycle % = (CCR / (ARR + 1)) × 100

- `__HAL_TIM_SET_AUTORELOAD(htim, value)` - Set PWM period (ARR register)
  - Example: `__HAL_TIM_SET_AUTORELOAD(&htim4, 999)` sets period
  - PWM Frequency = timer_clock / (ARR + 1)

- `__HAL_TIM_GET_AUTORELOAD(htim)` - Read current ARR value
  - Example: `uint32_t period = __HAL_TIM_GET_AUTORELOAD(&htim4)`

- `HAL_TIM_GenerateEvent(htim, TIM_EVENTSOURCE_UPDATE)` - Force immediate register update
  - Example: `HAL_TIM_GenerateEvent(&htim4, TIM_EVENTSOURCE_UPDATE)` refreshes ARR/CCR

### GPIO Control Functions (for reference)

- `HAL_GPIO_WritePin(GPIOx, GPIO_Pin, PinState)` - Set digital output (not used for PWM)
  - Example: `HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET)` turns ON a GPIO pin
  
- `HAL_GPIO_ReadPin(GPIOx, GPIO_Pin)` - Read digital input
  - Example: `if(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_RESET)` detects button press

### Timing & System Functions

- `HAL_Delay(ms)` - Block execution for specified milliseconds
  - Example: `HAL_Delay(1000)` pauses for 1 second
  
- `HAL_GetTick()` - Get current system tick count (milliseconds since boot)
  - Useful for non-blocking timing and seeding random numbers
  - Example: `uint32_t time_now = HAL_GetTick()`

## PWM Theory - Detailed Reference

### ARR (Auto-Reload Register) - Frequency Control

The **ARR register** determines the PWM frequency by defining the period (how many timer ticks make one complete cycle):

$$f_{PWM} = \frac{f_{tick}}{ARR + 1}$$

Where:
- $f_{PWM}$ = desired output frequency (Hz)
- $f_{tick}$ = timer tick frequency (1 MHz for this lab)
- $ARR$ = Auto-Reload Register value

**To calculate ARR for a desired frequency:**

$$ARR = \frac{f_{tick}}{f_{PWM}} - 1$$

**Example 1: 1 kHz PWM with 1 MHz timer clock**

$$ARR = \frac{1,000,000}{1000} - 1 = 999$$

This means the timer counts from 0 to 999 (1000 total counts), and this period repeats 1000 times per second = 1 kHz.

**Example 2: 100 Hz PWM with 1 MHz timer clock**

$$ARR = \frac{1,000,000}{100} - 1 = 9,999$$

For slower flashing effects, use lower frequencies with larger ARR values.

### CCR (Compare Register) - Duty Cycle & Brightness Control

The **CCR register** determines the duty cycle (what percentage of the period the LED is ON):

$$\text{Duty Cycle (\%)} = \frac{CCR}{ARR + 1} \times 100\%$$

Where:
- $CCR$ = Compare Register value (when the output goes LOW)
- $ARR + 1$ = total counts per period

**To calculate CCR for a desired duty cycle:**

$$CCR = \frac{(ARR + 1) \times \text{Duty Cycle (\%)}}{100}$$

**Example 3: 50% brightness with ARR=999 (1 kHz)**

For 50% duty cycle:
$$CCR = \frac{(999 + 1) \times 50}{100} = \frac{1000 \times 50}{100} = 500$$

This means:
- LED is ON for 500 timer ticks (from 0 to 499)
- LED is OFF for 500 timer ticks (from 500 to 999)
- Total period: 1000 ticks = 1 kHz ✓
- Duty: 500/1000 = 50% ✓

**Example 4: 75% brightness with ARR=999**

$$CCR = \frac{1000 \times 75}{100} = 750$$

LED is ON for 750 ticks, OFF for 250 ticks.

**Example 5: 10% brightness (very dim) with ARR=999**

$$CCR = \frac{1000 \times 10}{100} = 100$$

LED is ON for 100 ticks, OFF for 900 ticks. Very dim because LED is mostly OFF.

### Special Cases

**100% Duty (Maximum Brightness):**
$$CCR = ARR$$

The LED is ON for the entire period (including when the counter resets).

**0% Duty (LED Off):**
$$CCR = 0$$

The LED is OFF for the entire period. PWM actually stops in this case.

### Brightness Effect

At high frequencies (1 kHz+), the human eye **blends the PWM signal** and perceives brightness proportional to duty cycle:
- 10% duty = very dim (LED blinks so fast you see only a faint glow)
- 50% duty = medium brightness (LED blinks so fast it looks half-lit)
- 100% duty = maximum brightness (LED always ON)

At low frequencies (< 100 Hz), you **see the LED flashing** rather than a smooth brightness change:
- 10 Hz at 50% duty = visible flashing, appears dim
- 1 Hz at 50% duty = clearly see ON/OFF cycles (0.5 sec ON, 0.5 sec OFF)

### Complete Example Calculation

**Problem:** Generate 2 kHz PWM with 75% brightness

**Solution:**

Step 1: Calculate ARR for frequency
$$ARR = \frac{1,000,000}{2000} - 1 = 500 - 1 = 499$$

Step 2: Calculate CCR for 75% brightness
$$CCR = \frac{(499 + 1) \times 75}{100} = \frac{500 \times 75}{100} = 375$$

Step 3: Verify the result
$$f_{PWM} = \frac{1,000,000}{499 + 1} = \frac{1,000,000}{500} = 2000 \text{ Hz} \,\checkmark$$
$$\text{Duty} = \frac{375}{500} \times 100\% = 75\% \,\checkmark$$

### Timer Register Range

- **ARR**: 0 to 65,535 (16-bit register)
- **CCR**: 0 to ARR (must not exceed ARR)

If CCR > ARR, it gets clamped to ARR (100% duty).

With a 1 MHz timer and 16-bit ARR:
- **Minimum frequency**: $\frac{1,000,000}{65,536} \approx 15.3$ Hz
- **Maximum frequency**: $\frac{1,000,000}{1} = 1$ MHz

## Example: Using the PWM Library

```c
// Configure PWM
PWM_cfg_t pwm_cfg = {
    .htim = &htim4,
    .channel = TIM_CHANNEL_1,
    .tick_freq_hz = 1000000,  // 1MHz timer clock
    .min_freq_hz = 10,
    .max_freq_hz = 50000,
    .setup_done = 0
};

// Initialize
PWM_Init(&pwm_cfg);

// Set frequency and 50% duty cycle
PWM_Set(&pwm_cfg, 1000, 50);

// Later: adjust just the brightness
PWM_SetDuty(&pwm_cfg, 75);  // 75% brightness

// Or adjust just frequency (preserves duty cycle)
PWM_SetFreq(&pwm_cfg, 2000);  // 2 kHz

// Turn off LED
PWM_Off(&pwm_cfg);
```

## Key Concepts

### ⚠️ LCD & PWM Pin Conflict (Important!)

**Note**: The LCD driver hardware initialization overwrites GPIOB registers, which can destroy the PWM pin configuration. This is why `MX_TIM4_Init()` is called **after** `LCD_init()` in this code - it re-establishes the PB6 alternate function connection to TIM4.

If you move initialization functions, ensure this order:
1. `MX_GPIO_Init()` - Set all pins to default
2. `MX_USART2_UART_Init()` - Initialize UART
3. `LCD_init()` - Initialize LCD (overwrites GPIOB)
4. `MX_TIM4_Init()` - Reconfigure PB6 for PWM (after LCD init)
5. `PWM_Init()` - Initialize PWM library

### PWM Output Verification

To verify PWM is working:
1. **Visual**: LED brightness changes smoothly as duty cycle increases
2. **Oscilloscope**: Connect probe to PB6, see square wave with varying duty cycle
3. **Serial Monitor**: Watch `printf()` output showing frequency and duty values
4. **Logic Analyzer**: Capture PWM waveform to verify timing and frequency

